# Dockerfile for Load Testing Infrastructure
# Multi-stage build for comprehensive load testing environment

# Stage 1: Base dependencies
FROM node:18-alpine AS base
RUN apk add --no-cache \
    curl \
    bash \
    jq \
    bc \
    python3 \
    py3-pip \
    docker-cli \
    && pip3 install --upgrade pip

# Stage 2: K6 installation
FROM base AS k6-installer
RUN apk add --no-cache --virtual .build-deps \
    build-base \
    git \
    && cd /tmp \
    && wget https://github.com/grafana/k6/releases/download/v0.47.0/k6-v0.47.0-linux-amd64.tar.gz \
    && tar -xzf k6-v0.47.0-linux-amd64.tar.gz \
    && mv k6-v0.47.0-linux-amd64/k6 /usr/local/bin/ \
    && chmod +x /usr/local/bin/k6 \
    && rm -rf /tmp/* \
    && apk del .build-deps

# Stage 3: Artillery and Node.js dependencies
FROM k6-installer AS node-deps
WORKDIR /app

# Copy package files
COPY package.json package-lock.json ./

# Install Node.js dependencies
RUN npm ci --only=production \
    && npm install -g artillery@latest \
    && npm cache clean --force

# Stage 4: Load testing runtime
FROM node-deps AS loadtest-runtime

# Install additional tools for load testing
RUN apk add --no-cache \
    htop \
    netcat-openbsd \
    tcpdump \
    iftop \
    iotop \
    stress-ng

# Create load test user
RUN addgroup -g 1001 loadtest \
    && adduser -D -u 1001 -G loadtest loadtest

# Set up directories
RUN mkdir -p /app/load-tests /app/reports /app/data /app/logs \
    && chown -R loadtest:loadtest /app

# Copy load test files
COPY --chown=loadtest:loadtest load-tests/ /app/load-tests/
COPY --chown=loadtest:loadtest scripts/performance-test.js /app/scripts/
COPY --chown=loadtest:loadtest package.json /app/

# Copy monitoring configurations
COPY --chown=loadtest:loadtest load-tests/monitoring/ /app/monitoring/

# Create entrypoint script
RUN cat > /app/entrypoint.sh << 'EOF'
#!/bin/bash
set -e

# Initialize logging
exec > >(tee -a /app/logs/loadtest.log) 2>&1
echo "$(date): Starting Load Test Infrastructure"

# Environment validation
if [ -z "$LOAD_TEST_BASE_URL" ]; then
    echo "WARNING: LOAD_TEST_BASE_URL not set, using default"
    export LOAD_TEST_BASE_URL="http://app:3000"
fi

# Wait for dependencies
echo "Waiting for dependencies..."
for service in prometheus:9090 grafana:3000; do
    host=$(echo $service | cut -d: -f1)
    port=$(echo $service | cut -d: -f2)
    
    echo "Waiting for $host:$port..."
    for i in {1..30}; do
        if nc -z "$host" "$port"; then
            echo "$host:$port is ready"
            break
        fi
        sleep 2
    done
done

# Verify target system
echo "Verifying target system: $LOAD_TEST_BASE_URL"
if curl -f --max-time 30 "$LOAD_TEST_BASE_URL/api/health" > /dev/null 2>&1; then
    echo "✅ Target system is healthy"
else
    echo "❌ Target system health check failed"
    if [ "$STRICT_HEALTH_CHECK" = "true" ]; then
        exit 1
    fi
fi

# Set up monitoring
if [ "$ENABLE_MONITORING" != "false" ]; then
    echo "Setting up monitoring..."
    # Start background monitoring processes
    nohup /app/monitoring/system-monitor.sh > /app/logs/system-monitor.log 2>&1 &
fi

# Execute load test command or default action
if [ "$#" -eq 0 ]; then
    echo "Starting interactive load test environment..."
    exec /bin/bash
else
    echo "Executing: $@"
    exec "$@"
fi
EOF

# System monitoring script
RUN cat > /app/monitoring/system-monitor.sh << 'EOF'
#!/bin/bash

# System monitoring for load testing
INTERVAL=${MONITOR_INTERVAL:-30}
LOG_FILE="/app/logs/system-metrics.log"

echo "$(date): Starting system monitoring (interval: ${INTERVAL}s)" | tee -a "$LOG_FILE"

while true; do
    timestamp=$(date -Iseconds)
    
    # CPU usage
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//')
    
    # Memory usage
    mem_total=$(free -m | awk '/^Mem:/{print $2}')
    mem_used=$(free -m | awk '/^Mem:/{print $3}')
    mem_percent=$(awk "BEGIN {printf \"%.1f\", $mem_used/$mem_total*100}")
    
    # Disk usage
    disk_percent=$(df / | awk 'NR==2{print $5}' | sed 's/%//')
    
    # Network stats
    rx_bytes=$(cat /proc/net/dev | grep eth0 | awk '{print $2}' || echo 0)
    tx_bytes=$(cat /proc/net/dev | grep eth0 | awk '{print $10}' || echo 0)
    
    # Log metrics
    echo "$timestamp,cpu=$cpu_usage,mem_percent=$mem_percent,mem_used=${mem_used}MB,mem_total=${mem_total}MB,disk_percent=$disk_percent,rx_bytes=$rx_bytes,tx_bytes=$tx_bytes" >> "$LOG_FILE"
    
    sleep "$INTERVAL"
done
EOF

# Make scripts executable
RUN chmod +x /app/entrypoint.sh /app/monitoring/system-monitor.sh

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# Switch to load test user
USER loadtest

# Set working directory
WORKDIR /app

# Default environment variables
ENV LOAD_TEST_ENV=docker
ENV LOAD_TEST_MAX_USERS=10000
ENV LOAD_TEST_DURATION=1800s
ENV LOAD_TEST_RAMP_UP=600s
ENV ENABLE_MONITORING=true
ENV MONITOR_INTERVAL=30

# Expose ports
EXPOSE 6565 8080 9090

# Set entrypoint
ENTRYPOINT ["/app/entrypoint.sh"]

# Default command
CMD ["node", "scripts/performance-test.js"]

# Labels for better Docker management
LABEL maintainer="Load Testing Team"
LABEL version="1.0.0"
LABEL description="Comprehensive load testing infrastructure with K6, Artillery, and monitoring"
LABEL load-test.type="orchestrator"
LABEL load-test.tools="k6,artillery,prometheus,grafana"