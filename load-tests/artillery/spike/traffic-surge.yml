# Artillery Traffic Surge Testing Configuration
# Simulates sudden traffic spikes to test auto-scaling and resilience

config:
  target: "{{ $processEnvironment.LOAD_TEST_BASE_URL || 'http://localhost:3000' }}"
  
  # Optimized for spike testing
  http:
    timeout: 60  # Longer timeout for spike conditions
    pool: 200    # Larger connection pool
    maxSockets: 200
    keepAlive: true
    
  # Spike test phases - multiple surge patterns
  phases:
    # Baseline - Normal traffic
    - duration: 300
      arrivalRate: 50
      name: "Baseline traffic"
      
    # Spike 1: Sudden 10x increase
    - duration: 30
      arrivalRate: 500
      name: "Spike 1 - 10x surge"
      
    # Recovery 1
    - duration: 120  
      arrivalRate: 500
      rampTo: 50
      name: "Recovery 1"
      
    # Baseline 2
    - duration: 300
      arrivalRate: 50
      name: "Baseline 2"
      
    # Spike 2: Extreme surge (20x)
    - duration: 15
      arrivalRate: 1000
      name: "Spike 2 - 20x surge"
      
    # Sustained spike
    - duration: 180
      arrivalRate: 1000
      name: "Sustained extreme load"
      
    # Recovery 2  
    - duration: 300
      arrivalRate: 1000
      rampTo: 50
      name: "Recovery 2"
      
    # Baseline 3
    - duration: 180
      arrivalRate: 50
      name: "Final baseline"
      
    # Spike 3: Gradual build-up to maximum
    - duration: 60
      arrivalRate: 50
      rampTo: 2000
      name: "Gradual build to maximum"
      
    # Maximum spike
    - duration: 120
      arrivalRate: 2000  
      name: "Maximum spike (2000 req/sec)"
      
    # Final recovery
    - duration: 300
      arrivalRate: 2000
      rampTo: 0
      name: "Final recovery"

  # Test data for spike scenarios
  payload:
    path: "../data/spike-test-data.csv"
    fields:
      - "spikeId"
      - "userId"
      - "endpoint" 
      - "payload"
      - "priority"
    order: random  # Random order for realistic traffic
    skipHeader: true
    
  # Headers optimized for spike testing
  defaults:
    headers:
      Content-Type: "application/json"
      Accept: "application/json"
      User-Agent: "Artillery-Spike/1.0"
      Connection: "keep-alive"
      Cache-Control: "no-cache"
      
  # Variables for spike test scenarios
  variables:
    maxUsers: 50000
    priorityLevels: ["low", "medium", "high", "critical"]
    spikeReasons: ["viral_content", "news_event", "promotion", "system_alert"]
    
  # Plugin configuration for spike monitoring
  plugins:
    metrics-by-endpoint:
      useOnlyRequestNames: true
      stripQueryString: true
    publish-metrics:
      - type: statsd
        host: "{{ $processEnvironment.STATSD_HOST || 'localhost' }}"
        port: "{{ $processEnvironment.STATSD_PORT || 8125 }}"
        prefix: "artillery.spike"
        tags:
          - "test_type:spike"
          - "environment:{{ $processEnvironment.ENVIRONMENT || 'local' }}"
    expect:
      outputFormat: json
      reportFailuresAsErrors: true
      
  # Spike test specific settings
  statsInterval: 5  # More frequent stats during spikes
  maxVusers: 20000
  rateLimit: 2500  # Higher rate limit for spike testing

# Spike test expectations (more tolerant during surges)  
expectations:
  - http.response_time.p99: 2000   # 2 seconds max during spikes
  - http.response_time.p95: 1000   # 1 second for 95th percentile
  - http.response_time.median: 300  # 300ms median
  - http.codes.200: 95             # 95% success rate (allow for surge impact)
  - http.codes.4xx: 3              # Max 3% client errors  
  - http.codes.5xx: 2              # Max 2% server errors during spikes
  - http.codes.503: 5              # Allow up to 5% service unavailable during extreme spikes

# Spike test scenarios - different traffic patterns
scenarios:
  # High-priority traffic (critical operations)
  - name: "Critical Operations"
    weight: 30
    flow:
      - think: 0.1  # Minimal think time for urgent requests
      
      - get:
          url: "/api/health"
          name: "Health Check - Critical"
          headers:
            X-Priority: "critical"
          expect:
            - statusCode: 200
            - responseTime: 500
            
      - post:
          url: "/api/auth/login"
          name: "Authentication - Critical"
          json:
            email: "critical_user{{ $randomInt(1, 1000) }}@example.com"
            password: "LoadTest123!"
            priority: "critical"
          capture:
            - json: "$.token"
              as: "criticalToken"
          expect:
            - statusCode: [200, 401, 503]
            
      - get:
          url: "/api/alerts"
          name: "Alerts - Critical"
          headers:
            Authorization: "Bearer {{ criticalToken }}"
            X-Priority: "critical"
          expect:
            - statusCode: [200, 401, 503]

  # Standard user traffic (normal operations)
  - name: "Standard Operations" 
    weight: 50
    flow:
      - think: "{{ $randomNumber(0.5, 2) }}"
      
      - get:
          url: "/api/metrics?range=1h"
          name: "Metrics - Standard"
          expect:
            - statusCode: [200, 429, 503]  # Allow rate limiting
            
      - think: 1
      
      - get:
          url: "/api/events"
          name: "Events - Standard"
          expect:
            - statusCode: [200, 429, 503]
            
      - think: "{{ $randomNumber(1, 3) }}"
      
      - post:
          url: "/api/events"
          name: "Event Creation - Standard"
          json:
            type: "user_action"
            data:
              spike_id: "{{ spikeId }}"
              reason: "{{ spikeReasons[$randomInt(0, 3)] }}"
              timestamp: "{{ $timestamp }}"
          expect:
            - statusCode: [200, 201, 429, 503]

  # Heavy data operations (resource intensive)
  - name: "Heavy Operations"
    weight: 15
    flow:
      - think: 2
      
      - get:
          url: "/api/metrics?range=24h&detailed=true&format=json"
          name: "Heavy Data Query"
          expect:
            - statusCode: [200, 429, 503, 504]  # Allow timeouts during spikes
            - responseTime: 10000  # 10 second timeout
            
      - think: 3
      
      - post:
          url: "/api/export/csv"
          name: "Data Export"
          json:
            dateRange: "7d"
            includeDetails: true
            format: "csv"
          expect:
            - statusCode: [200, 202, 429, 503]  # Allow async processing
            
  # Background operations (low priority)
  - name: "Background Operations"
    weight: 5
    flow:
      - think: 5
      
      - get:
          url: "/api/notifications/preferences"
          name: "Preference Sync"
          expect:
            - statusCode: [200, 429, 503]
            
      - think: 10
      
      - post:
          url: "/api/metrics/aggregate"
          name: "Background Aggregation"  
          json:
            operation: "daily_summary"
            priority: "low"
          expect:
            - statusCode: [200, 202, 429, 503]

# Additional spike-specific scenarios for extreme conditions
  # Circuit breaker testing
  - name: "Circuit Breaker Test"
    weight: 10
    flow:
      # Rapid-fire requests to trigger circuit breaker
      - loop:
          - get:
              url: "/api/health"
              name: "Circuit Breaker Trigger"
          count: 10
          whileTrue: "response.statusCode < 500"
          
      - think: 5  # Wait for circuit breaker recovery
      
      - get:
          url: "/api/health"  
          name: "Circuit Breaker Recovery"
          expect:
            - statusCode: [200, 503]

# Before spike test setup
before:
  - log: "=== Starting Artillery Traffic Surge Test ==="
  - log: "Target: {{ target }}"
  - log: "Test pattern: Multiple spike scenarios"
  - log: "Peak rate: 2000 req/sec"
  - log: "Testing auto-scaling and resilience"
  - log: "Monitoring circuit breakers and rate limiting"

# After spike test analysis
after:  
  - log: "=== Traffic Surge Test Completed ==="
  - log: "Analyze the following:"
  - log: "1. Auto-scaling response times"
  - log: "2. Circuit breaker activation patterns"  
  - log: "3. Rate limiting effectiveness"
  - log: "4. Error rate spikes and recovery"
  - log: "5. Response time degradation during surges"
  - log: "6. Database connection pool behavior"
  - log: "7. Cache performance under pressure"